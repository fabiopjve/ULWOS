/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  ULWOS testing                          */
/*      FILE         :  main.c                                 */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  RL78 - G13                             */
/*      CPU TYPE     :  R5F100LE                               */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/                                   
                                                                                            
                                                                                            
/************************************************************************/
/*    File Version: V1.00                                               */
/*    Date Generated: 02/26/2016                                        */
/************************************************************************/

#include "iodefine.h"
#include "iodefine_ext.h"
#include "myrl78.h"
#include "interrupt_handlers.h"
#include "ulwos.h"
#include "lcd_8x2.h"

#define LED 	P6_bit.no3
#define LED_DIR PM6_bit.no3

ULWOS_SEMAPHORE lcd_semaphore;
ULWOS_SEMAPHORE test_semaphore;
unsigned char ready=0;

void task1(void){
	volatile unsigned long count;
	LED_DIR = 0;
	while (1){
		// blinks a LED at 2Hz (250ms on and 250ms off)
		LED = 0;
		ulwos_delayms(250);
		LED = 1;
		ulwos_delayms(250);
	}
}

void task2(void){
	volatile unsigned char aux;
	volatile unsigned long temp;
	ulwos_semaphore_acquire(&lcd_semaphore);
	LCD_init(DISPLAY_8x5|_2LINES,DISPLAY_ON|CURSOR_OFF|CURSOR_FIXED);
	ulwos_semaphore_release(&lcd_semaphore);
	while (1){
		ulwos_semaphore_acquire(&lcd_semaphore);
		LCD_write_char('\f');   // clear the display
		LCD_pos_xy(0,0);
		LCD_write_string("Testing");
		ulwos_semaphore_release(&lcd_semaphore);
		// write an up counting on the display (0 up to 99)
		for (aux=0;aux<100;aux++){
			ulwos_semaphore_acquire(&lcd_semaphore);
			LCD_pos_xy(0,1);
			LCD_print_char(aux);
			ulwos_semaphore_release(&lcd_semaphore);
			ulwos_delayms(250);	// wait 250ms on each count
		}
		// now we write WT (wait) on the display until ready==true
		ulwos_semaphore_acquire(&lcd_semaphore);
		LCD_pos_xy(0,1);
		LCD_write_string("WT");
		ulwos_semaphore_release(&lcd_semaphore);
		do {
			ulwos_semaphore_acquire(&test_semaphore);
			if (ready) {
				ready = 0;
				ulwos_semaphore_release(&test_semaphore);
				break;
			}
			ulwos_semaphore_release(&test_semaphore);
			ulwos_delayms(5);
		} while (1);
	}
}

void task3(void){
	volatile unsigned char aux;
	while (1){
		// write a down counting on the display (99 down to 0)
		ulwos_semaphore_acquire(&lcd_semaphore);
		LCD_pos_xy(3,1);
		LCD_print_char(aux);
		LCD_write_char(' ');
		ulwos_semaphore_release(&lcd_semaphore);
		ulwos_delayms(100);	// wait 100ms on each count
		aux--;
		if (aux>100) aux = 99;
	}
}

void task4(void){
	volatile unsigned char aux;
	while (1){
		// write an up counting on the display (0 up to 100)
		for (aux=0;aux<100;aux++){
			ulwos_semaphore_acquire(&lcd_semaphore);
			LCD_pos_xy(6,1);
			LCD_print_char(aux);
			LCD_write_char(' ');
			ulwos_semaphore_release(&lcd_semaphore);
			ulwos_delayms(400); // wait 400ms on each count
		}
		// after 100 counts, set ready to true
		ulwos_semaphore_acquire(&test_semaphore);
		ready = 1;
		ulwos_semaphore_release(&test_semaphore);
		ulwos_delayms(20);	// wait 20ms and start it again
	}
}

void main(void){
	ULWOS_TASKHANDLER tk1 = ulwos_create_task(&task1);
	ULWOS_TASKHANDLER tk2 = ulwos_create_task(&task2);
	ULWOS_TASKHANDLER tk3 = ulwos_create_task(&task3);
	ULWOS_TASKHANDLER tk4 = ulwos_create_task(&task4);
	ulwos_semaphore_init(&lcd_semaphore);
	ulwos_semaphore_init(&test_semaphore);
	ulwos_start();
	// the following code is never executed!!! It is here "just in case" ;)
	while (1){
	}
}
